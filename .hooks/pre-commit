#!/bin/sh
spotlessApply() {
  # We pass in ratchetFrom here to ensure that we only format the files that have changed since the last commit
  if command -v mvn >/dev/null 2>&1; then    # Check if mvn command exists to support GitHub Desktop on Windows
    mvn spotless:apply -DratchetFrom=HEAD -q # Requires Maven to be installed
  else
    ./mvnw spotless:apply -DratchetFrom=HEAD -q # Otherwise call maven wrapper for Mac-OS / Unix / Git for Windows
  fi
}

echo "[git pre-commit hook] - Stashing unstaged changes"
# Add unstaged changes to staged files so that we can prevent conflicts when un-stashing
STAGED_FILES=$(git diff --name-only --cached --diff-filter=ad)
echo "$STAGED_FILES" | xargs git add

git stash -q --keep-index

echo "[git pre-commit hook] - Running spotless:apply"
spotlessApply
SPOTLESS_APPLY_RESULT=$?

echo "[git pre-commit hook] - Staging formatting changes"
git add -u

echo "[git pre-commit hook] - Un-stashing changes"
git stash pop -q

conflictedFiles="$(git diff --name-only --diff-filter=U)"
if [ -n "$conflictedFiles" ]; then
  echo "[git pre-commit hook] - Conflicted files: $conflictedFiles"

  for conflictedFile in $conflictedFiles; do
    echo "[git pre-commit hook] - Resolving conflict for $conflictedFile"
    git checkout --theirs "$(pwd)/$conflictedFile"
    git restore --staged "$(pwd)/$conflictedFile"

    if command -v mvn >/dev/null 2>&1; then
      mvn spotless:apply -DspotlessFiles="$conflictedFile" -q
    else
      ./mvnw spotless:apply -DspotlessFiles="$conflictedFile" -q
    fi

    for stagedFile in $STAGED_FILES; do
      echo "[git pre-commit hook] - Checking if $stagedFile is the same as $conflictedFile"
      if [ "$stagedFile" = "$conflictedFile" ]; then
        echo "[git pre-commit hook] - Adding $conflictedFile back to staged files"
        git add "$conflictedFile"
      fi
    done

#    echo "$STAGED_FILES" | xargs git add
  done
fi

git diff --cached --quiet
GIT_DIFF=$?
if [ "$GIT_DIFF" -eq 0 ]; then
  echo "[git pre-commit hook] - No changes to commit"
  # We end up with no changes to commit here due to the stashing and un-stashing of changes
  # where we stash a bad formatting change, apply the formatting, and then un-stash the bad formatting change.
  #
  # Example:
  #   - We accidentally indented 1 line in a file by an extra space. This causes us to stash the extra space, apply the
  #     formatting which will remove the extra space, and then un-stash the extra space back into the file that the
  #     formatter just removed. By re-running spotless:apply, we remove the extra space again and remove the file from
  #     the staging area.
  #
  # This results in no changes to commit, so we exit with 1 to prevent committing an empty commit.
  # We run spotless:apply again here to ensure that the files are formatted correctly and to remove the file from the staging area.
  spotlessApply
  exit 1
fi

# Return the 'spotless:apply' exit code
exit $SPOTLESS_APPLY_RESULT
